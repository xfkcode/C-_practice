# 数组

在数组中并没有真正意义上的指针，但可以把索引当做数组中的指针，这样也可以在数组中施展双指针技巧

### 1. 快慢指针技巧

**快慢指针，就是两个指针同向而行，一快一慢** 

#### 1.1 删除有序数组中的重复项

:point_right:[**LeetCode26. 删除有序数组中的重复项**](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/) 

:alien:**思路解析：** 

- 让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步
- 当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果

```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        if(nums.size()==0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[slow]!=nums[fast]){
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
};
```

【:ticket:】扩展链表 
             [**LeetCode83. 删除排序链表中的重复元素**](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/submissions/) 

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(head==nullptr){
            return nullptr;
        }
        ListNode* slow = head;
        ListNode* fast = head;
        while(fast!=nullptr){
            if(fast->val!=slow->val){
                slow->next = fast; 
                slow = slow->next;
            }
            fast = fast->next; 
        }
        slow->next = nullptr;
        return head;
    }
};
```

#### 1.2 **原地删除指定元素** 

:point_right:[**LeetCode27. 移除元素**](https://leetcode.cn/problems/remove-element/description/) 

:alien:**思路解析：** 

- 如果 `fast` 遇到值为 `val` 的元素，则直接跳过，否则就赋值给 `slow` 指针，并让 `slow` 前进一步

```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        if(nums.size()==0){
            return 0;
        }
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[fast]!=val){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
};
```

- [x] 注意这里和有序数组去重的解法有一个细节差异  
  先给 `nums[slow]` 赋值然后再给 `slow++`，这样可以保证 `nums[0..slow-1]` 是不包含值为 `val` 的元素的，最后的结果数组长度就是 `slow` 

【:ticket:】扩展  
             [**LeetCode283. 移动零**](https://leetcode.cn/problems/move-zeroes/description/) 

:alien:**思路解析：** 

- 首先原地删除 `nums` 中的所有 0
- 再把后面的元素都赋值为 0 即可

```C++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int slow = 0;
        int fast = 0;
        while(fast<nums.size()){
            if(nums[fast]!=0){
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        for(int i=slow;i<nums.size();i++){
            nums[i] = 0;
        }
    }
};
```

### 2. 左右指针技巧

#### 2.1 二分查找

```C++

```

#### 2.2 两数之和



#### 2.3 反转数组



#### 2.4 回文串判断
