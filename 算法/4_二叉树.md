# 二叉树

二叉树解题的思维模式分两类：

**1、是否可以通过遍历一遍二叉树得到答案**？如果可以，用一个 `traverse` 函数配合外部变量来实现，这叫「遍历」的思维模式。

**2、是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案**？如果可以，写出这个递归函数的定义，并充分利用这个函数的返回值，这叫「分解问题」的思维模式。

无论使用哪种思维模式，都需要思考：

**如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候（前/中/后序位置）做**？

### 前中后序

二叉树遍历框架：

```c++
void traverse(TreeNode root) {
    if (root == nullptr) {
        return;
    }
    // 前序位置
    traverse(root.left);
    // 中序位置
    traverse(root.right);
    // 后序位置
}
```

### 1.1 二叉树的最大深度

:point_right:[**LeetCode104. 二叉树的最大深度**](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/) 

:alien:**思路解析：** 

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int res = 0;							// 记录最大深度
    int depth = 0;							// 记录遍历到的节点的深度
    int maxDepth(TreeNode* root) {
        traverse(root);
        return res;
    }
    void traverse(TreeNode* root) {			// 二叉树遍历框架
        if(root==nullptr) {
            return;
        }
        // 前序位置
        depth++;
        if(root->left==nullptr && root->right==nullptr) {
            res = depth>res ? depth : res;	// 到达叶子节点，更新最大深度
        }
        traverse(root->left);
        traverse(root->right);
        // 后序位置
        depth--;
    }
};
```



```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr) {
            return 0;
        }
        //计算左右子树的最大深度
        int leftMax = maxDepth(root->left);
        int rightMax = maxDepth(root->right);
        //比较左右子树，返回较大者+1
        int res = (leftMax>rightMax ? leftMax : rightMax) + 1;
        return res;
    }
};
```

