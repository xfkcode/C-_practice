# 链表:cactus:

### 1. 合并两个有序链表

:point_right:[**LeetCode21. 合并两个有序链表**](https://leetcode.cn/problems/merge-two-sorted-lists/description/) 

:alien:**思路解析：** 

- 双指针 `p1` `p2` 分别指向两个链表头结点
- 创建新链表指针 `p` 维护（技巧：虚拟头结点 `dummy`）
- 遍历两个链表，较小的结点优先给 `p` 指针，终止条件存在链表（任意一个或两个都）遍历完成
- 判断 `p1` `p2` 是否非空，非空则追加给 `p` 指针

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        // 虚拟头结点
        ListNode* dummy = new ListNode(-1);
        ListNode* p = dummy;
        ListNode* p1 = list1; 
        ListNode* p2 = list2;
        
        while(p1!=nullptr && p2!=nullptr){
            // 比较 p1 和 p2 两个指针
        	// 将值较小的的节点接到 p 指针
            if (p1->val <= p2->val){
                p->next = p1;
                p1 = p1->next;
            }
            else{
                p->next = p2;
                p2 = p2->next;
            }
            p = p->next;
        }
        if (p1！=nullptr){
            p->next = p1;
        }
        if (p2！=nullptr){
            p->next = p2;
        }
        return dummy->next;
    }
};
```

- [x] **「虚拟头结点」技巧，也就是 `dummy` 节点** :  
  如果不使用 `dummy` 虚拟节点，代码会复杂很多，而有了 `dummy` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。  
  **当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理**。

### 2. 链表的分解

:point_right:[**Leetcode86. 分隔链表**](https://leetcode.cn/problems/partition-list/) 

:alien:**思路解析：** 

- `p` 指针遍历原链表，比较分区，终止条件原链表遍历完成
- 双指针 `p1` `p2` 分别维护两个分区新链表（技巧：虚拟头结点 `dummy1` `dummy2`）
- 断开原链表中每个节点

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* partition(ListNode* head, int x) {
        // 存放小于 x 的链表的虚拟头结点
        ListNode* dummy1 = new ListNode(-1);
        // 存放大于等于 x 的链表的虚拟头结点
        ListNode* dummy2 = new ListNode(-1);
        // p1, p2 指针负责生成结果链表
        ListNode* p1 = dummy1;
        ListNode* p2 = dummy2;
        // p 负责遍历原链表，类似合并两个有序链表的逻辑
    	// 这里是将一个链表分解成两个链表
        ListNode* p = head;
        while (p!=nullptr){
            if (p->val < x){
                p1->next = p;
                p1 = p1->next;
            }
            else{
                p2->next = p;
                p2 = p2->next;
            }
            // 断开原链表中的每个节点的 next 指针
            ListNode* tmp = p->next;
            p->next = nullptr;
            p = tmp;
        }
        // 连接两个链表
        p1->next = dummy2->next;
        return dummy1->next;
    }
};
```

### 3. 合并 k 个有序链表

:point_right:[**Leetcode23. 合并K个升序链表**](https://leetcode.cn/problems/partition-list/) 

:alien:**思路解析：** 

```c++

```

### 4. 链表的倒数第 k 个节点

:point_right:[**Leetcode19. 删除链表的倒数第 N 个结点**](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/) 

:alien:**思路解析：** 

```c++

```

### 5. 链表的中点

:point_right:[**Leetcode876. 链表的中间结点**](https://leetcode.cn/problems/middle-of-the-linked-list/) 

:alien:**思路解析：** 

```c++

```

### 6. 链表是否包含环

:point_right:[**Leetcode141. 环形链表**](https://leetcode.cn/problems/linked-list-cycle/) 

:alien:**思路解析：** 

```c++

```

:point_right:[**Leetcode142. 环形链表 II**](https://leetcode.cn/problems/linked-list-cycle-ii/) 

:alien:**思路解析：** 

```c++

```

### 7. 链表是否相交

:point_right:[**Leetcode160. 相交链表**](https://leetcode.cn/problems/intersection-of-two-linked-lists/) 

:alien:**思路解析：** 

```c++

```

