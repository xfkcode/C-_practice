# 进程间通信

## 1. 进程间通信相关概念

### 1.1 什么是进程间通信

Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能 相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷贝到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，interProcess Communication）

### 1.2 进程间通信的方式

文件、管道、信号、共享内存、消息队列、套接字、命名管道等

常用的进程通信方式：

- 管道（使用最简单）
- 信号（开销最小）
- 共享映射区（无血缘关系）
- 本地套接字（最稳定）

## 2. 管道pipe

### 2.1 管道的概念

管道是一种最基本的IPC机制，也称匿名管道，应用于有血缘关系的进程之间，完成数据传递。调用pipe函数即可创建一个管道

- 管道的本质是一块内核缓冲区
- 由两个文件描述符引用，一个表示读端，一个表示写端
- 规定数据从管道的写端流入管道，从读端流出
- 当两个进程都终结的时候，管道也自动消失
- 管道的读端和写端默认都是阻塞的

### 2.2 管道的原理

- 管道的实质是内核缓冲区，内部使用环形队列实现
- 默认缓冲区大小为4K，可以使用 `ulimit -a` 命令获取大小
- 实际操作过程中缓冲区会根据数据压力做适当调整

### 2.3管道的局限性

- 数据一旦被读走，便不在管道中存在，不可反复读取
- 数据只能在一个方向流动，若要实现双向流动，必须使用两个管道
- 只能在有血缘关系的进程间使用管道

### 2.4 创建管道pipe函数

```C
#include <unistd.h>
```

- 函数作用：创建一个管道
- 函数原型：  
  ` int pipe(int fildes[2]);` 
- 函数参数：   
  `fildes[0]` 存放管道的读端，`fildes[1] `存放管道的写端
- 返回值：
  - 成功返回 0
  - 失败返回 -1，并设置 `errno` 值

### 2.5 父子进程使用管道通信

1. 父进程创建管道
2. 父进程 fork 子进程
3. 父进程关闭 `fildes[0/1]`，子进程关闭 `fildes[1/0]`  

```C
  1 //pipe函数测试
  2 #include<stdio.h>
  3 #include<stdlib.h>
  4 #include<string.h>
  5 #include<sys/types.h>
  6 #include<unistd.h>
  7 #include<sys/wait.h>
  8 
  9 int main()
 10 {   
 11     //创建管道
 12     int fd[2];
 13     int ret = pipe(fd);
 14     if (ret<0)
 15     {   
 16         perror("pipe error");
 17         return -1;
 18     }
 19     //创建子进程
 20     pid_t pid = fork();
 21     if (pid<0)
 22     {   
 23         perror("fork error");
 24         return -1;
 25     }
 26     else if (pid>0)     //父进程
 27     {   
 28         //关闭读端
 29         close(fd[0]);
 30         sleep(5);
 31         write(fd[1], "hello world", strlen("hello world"));
 32         wait(NULL);
 33     }
 34     else if (pid==0)        //子进程
 35     {   
 36         //关闭写端
 37         close(fd[1]);
 38         char buf[64];
 39         memset(buf, 0x00, sizeof(buf));
 40         int n = read(fd[0], buf, sizeof(buf));
 41         printf("read over,n==[%d],buf==[%s]\n",n,buf);
 42     }
 43     return 0;
 44 }

 >>>>执行结果
 read over,n==[11],buf==[hello world]
```

### 2.6 管道练习

【:pill:】父子进程间通信实现 `ps aus | grep bash` 

1. 创建管道pipe
2. 创建子进程fork
3. 在父进程中关闭读端 `fd[0]` 
4. 在子进程中关闭写端 `fd[1]` 
5. 在父进程中将标准输出重新定向到管道的写端
6. 在子进程中将标准输入重新定向到管道的读端
7. 在父进程调用execl函数执行 `ps aux` 命令
8. 在子进程调用execl函数执行 `grep bash` 命令
9. 在父进程中回收子进程wait函数

```C
  1 //父子进程管道模拟ps aux | grep bash
  2 #include<stdio.h>
  3 #include<stdlib.h>
  4 #include<string.h>
  5 #include<sys/types.h>
  6 #include<sys/wait.h>
  7 #include<unistd.h>
  8 
  9 int main()
 10 {
 11     //创建管道
 12     int fd[2];
 13     int ret = pipe(fd);
 14     if (ret<0)
 15     {
 16         perror("pipe error");
 17         return -1;
 18     }
 19     //创建子进程
 20     pid_t pid = fork();
 21     if (pid<0)
 22     {
 23         perror("fork error");
 24         return -1;
 25     }
 26     else if (pid>0)         //父进程
 27     {
 28         close(fd[0]);
 29         dup2(fd[1], STDOUT_FILENO);
 30         execl("/usr/bin/ps", "ps", "aux", NULL);
 31         perror("execl error");
 32         wait(NULL);
 33     }
 34     else if (pid==0)        //子进程
 35     {
 36         close(fd[1]);
 37         dup2(fd[0], STDIN_FILENO);
 38         execl("/usr/bin/grep", "grep", "--color==auto", "bash", NULL);
 39         perror("execl error");
 40     }
 41     return 0;
 42 }
```

【:pill:】兄弟进程间通信实现 `ps aus | grep bash` 

```C
```

### 3.7 管道的读写行为

- 读操作
  - 有数据  
    `read` 正常读，返回读出的字节数
  - 无数据  
    - 写端全部关闭  
      `read` 解除阻塞，返回 0 ，相当于读文件读到了尾部
    - 没有全部关闭  
      `read` 阻塞
- 写操作
  - 读端全部关闭  
    管道破裂，进程终止，内核给当前进程发 `SIGPIPE` 信号
  - 读端没有全部关闭
    - 缓冲区写满了  
      `write` 阻塞
    - 缓冲区没有满  
      继续 `write` 
