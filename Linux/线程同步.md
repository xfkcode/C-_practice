# 线程同步:eyeglasses: 

## 1. 互斥锁:closed_lock_with_key: 

【:ticket:】互斥锁使用步骤  
             1.定义互斥锁变量 `pthread_mutex_t mutex;`  
		     2.在main函数中初始化互斥锁 `pthread_mutex_init(&mutex, NULL);`  
    	     3.在共享资源操作上下加锁/解锁   
		         	`pthread_mutex_lock(&mutex);` 
                  	//共享资源操作代码//  
                 	`pthread_mutex_unlock(&mutex);`  
        	 4.在main函数中销毁互斥锁 `pthread_mutex_destroy(&mutex);` 

```C
  1 //互斥锁测试
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <pthread.h>
  8 
  9 //定义互斥锁
 10 pthread_mutex_t mutex;
 11 
 12 void *threadfunc1(void *arg)
 13 {
 14     while(1)
 15     {
 16         //加锁
 17         pthread_mutex_lock(&mutex);
 18         printf("HELLO ");
 19         sleep(rand()%3);
 20         printf("WORLD\n");
 21         //解锁
 22         pthread_mutex_unlock(&mutex);
 23         sleep(rand()%3);
 24     }
 25     pthread_exit(NULL);
 26 }
 27 
 28 void *threadfunc2(void *arg)
 29 {
 30     while(1)
 31     {
 32         pthread_mutex_lock(&mutex);
 33         printf("hello ");
 34         sleep(rand()%3);
 35         printf("world\n");
 36         pthread_mutex_unlock(&mutex);
 37         sleep(rand()%3);
 38     }
 39     pthread_exit(NULL);
 40 }
 41 
 42 int main()
 43 {
 44     //随机数
 45     srand(time(NULL));
 46     //互斥锁初始化
 47     pthread_mutex_init(&mutex, NULL);
 48 
 49     pthread_t thread1;
 50     int ret = pthread_create(&thread1, NULL, threadfunc1, NULL);
 51     if (ret!=0)
 52     {
 53         printf("pthread_create error, [%s]\n", strerror(ret));
 54         return -1;
 55     }
 56 
 57     pthread_t thread2;
 58     ret = pthread_create(&thread2, NULL, threadfunc2, NULL);
 59     if (ret!=0)
 60     {
 61         printf("pthread_create error, [%s]\n", strerror(ret));
 62         return -1;
 63     }
 64 
 65     pthread_join(thread1, NULL);
 66     pthread_join(thread2, NULL);
 67 
 68     //销毁互斥锁
 69     pthread_mutex_destroy(&mutex);
 70 
 71     return 0;
 72 }

 >>>>执行结果1（不加互斥锁）
 [xfk@centos PTHREAD]$ ./pthread_mutex 
 hello world
 HELLO WORLD
 hello HELLO WORLD
 HELLO world
 ^C
 >>>>执行结果2（加互斥锁）
 [xfk@centos PTHREAD]$ ./pthread_mutex 
 hello world
 HELLO WORLD
 HELLO WORLD
 ^C
```

### 死锁

用户使用互斥锁不当引起的一种现象

- 常见死锁
  1. 自己锁自己  
     :one: `pthread_mutex_lock(&mutex);`   
            `pthread_mutex_lock(&mutex);`   
     :two:  **不解锁**:key: `pthread_mutex_unlock(&mutex);` 
  2. 线程A拥有A锁，请求获得B锁；线程B拥有B锁，请求获得A锁；  
     这样造成线程A和线程B都不释放自己的锁，而且还想得到对方的锁，从而产生死锁
- 如何解决死锁
   - 让线程按照一定的顺序去访问共享资源
   - 再访问其他锁的时候，先将自己的锁解开
   - 调用 `pthread_mutex_trylock` 如果加锁不成功会立刻返回


## 2. 读写锁

**共享-独占锁：**  
读模式锁住时，是以共享模式锁住的；  
写模式锁住时，是以独占模式锁住的。

- 使用场合：对数据结构读的次数远大于写的情况
- 读写锁特性：
  - “写模式加锁”，解锁前所有对该锁加锁的线程都会被阻塞
  - “读模式加锁”，如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞  
                              读锁、写锁并行阻塞，写锁优先级高

【:triangular_flag_on_post:】读写锁是一把锁  
             **写独占，读共享，当读和写一起等待锁的时候，写的优先级高** 

### 2.1 读写锁相关函数

```C
#include <pthread.h>
```

【:shopping_cart:】`pthread_rwlock_t` 类型（struct）  
             `pthread_rwlock_t rwlock;` 该变量只有两种取值1/0

#### pthread_rwlock_init函数

- 函数作用：初始化一个读写锁（初值可看作1）
- 函数原型：  
  `int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：
  - `rwlock` 传出参数，读写锁变量
  - `attr` 读写锁属性，通常传NULL，默认属性（线程间共享）

#### pthread_rwlock_destroy函数

- 函数作用：销毁一个读写锁
- 函数原型：  
  `int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号

- 函数参数：`rwlock` 读写锁变量


#### pthread_rwlock_rdlock函数

- 函数作用：加读锁 
- 函数原型：  
  `int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：`rwlock` 读写锁变量

#### pthread_rwlock_tryrdlock函数

- 函数作用：尝试加读锁 
- 函数原型：  
  `int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：`rwlock` 读写锁变量

#### pthread_rwlock_wrlock函数

- 函数作用：加写锁 
- 函数原型：  
  `int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：`rwlock` 读写锁变量

#### pthread_rwlock_trywrlock函数

- 函数作用：尝试加写锁 
- 函数原型：  
  `int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：`rwlock` 读写锁变量

#### pthread_rwlock_unlock函数

- 函数作用：解锁 
- 函数原型：  
  `int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);`  
- 函数返回值：
  - 成功：返回 0
  - 失败：返回错误号
- 函数参数：`rwlock` 读写锁变量

### 2.2 读写锁：加锁/解锁

【:ticket:】读写锁使用步骤  
             1.定义读写锁变量 `pthread_rwlock_t rwlock;`  
		     2.在main函数中初始化读写锁 `pthread_rwlock_init(&rwlock, NULL);`  
    	     3.在共享资源操作上下加锁/解锁   
		         	`pthread_rwlock_rdlock(&rwlock);` 读锁  
		         	`pthread_rwlock_wrlock(&rwlock);` 写锁  
                     //共享资源操作代码//  
                 	`pthread_rwlock_unlock(&rwlock);`  
        	 4.在main函数中销毁读写锁 `pthread_rwlock_destroy(&rwlock);` 

```C
  1 //读写锁测试
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <pthread.h>
  8 
  9 int number = 0;
 10 
 11 //定义读写锁变量
 12 pthread_rwlock_t rwlock;
 13 
 14 void *thread_write(void *arg)
 15 {
 16     int i = *(int *)arg;
 17     int cur;
 18     while(1)
 19     {
 20         //加写锁
 21         pthread_rwlock_wrlock(&rwlock);
 22         cur = number;
 23         cur++;
 24         number = cur;
 25         printf("[%d]-W[%d]\n", i, cur);
 26         //解锁
 27         pthread_rwlock_unlock(&rwlock);
 28         sleep(rand()%3);
 29     }
 30 }
 31 
 32 void *thread_read(void *arg)
 33 {
 34     int i = *(int *)arg;
 35     int cur;
 36     while(1)
 37     {
 38         //加读锁
 39         pthread_rwlock_rdlock(&rwlock);
 40         cur = number;
 41         printf("[%d]-R[%d]\n", i, cur);
 42         //解锁
 43         pthread_rwlock_unlock(&rwlock);
 44         sleep(rand()%3);
 45     }
 46 }
 47 
 48 int main()
 49 {
 50     //读写锁初始化
 51     pthread_rwlock_init(&rwlock, NULL);
 52 
 53     int i = 0;
 54     int arr[8];
 55     pthread_t thread[8];
 56 
 57     //创建3个写线程
 58     for(i=0;i<3;i++)
 59     {
 60         arr[i] = i;
 61         pthread_create(&thread[i], NULL, thread_write, &arr[i]);
 62     }
 63     //创建5个读线程
 64     for(i=3;i<8;i++)
 65     {
 66         arr[i] = i;
 67         pthread_create(&thread[i], NULL, thread_read, &arr[i]);
 68     }
 69     //回收子线程
 70     int j = 0;
 71     for(j=0;j<8;j++)
 72     {
 73         pthread_join(thread[j], NULL);
 74     }
 75     //销毁读写锁
 76     pthread_rwlock_destroy(&rwlock);
 77 
 78     return 0;
 79 }

 >>>>执行结果（读的结果必然是最后一次写入的值）
 [xfk@centos PTHREAD]$ ./pthread_rwlock 
 [0]-W[1]
 [1]-W[2]
 [2]-W[3]
 [2]-W[4]
 [5]-R[4]
 [6]-R[4]
 [3]-R[4]
 ^C
```

## 3. 条件变量

### 链表

```C
typedef struct node{
    int data;
    struct node *next;
}NODE;

NODE *head = NULL;
NODE *pNode = NULL;

//[生产者线程] 链表插入
while(1)
{
    pNode = (NODE *)malloc(sizeof(NODE));
	pNode->data = rand()%1000;
    //加锁
	pNod->next = head;
	head = pNode;
    //通知消费者线程解除阻塞
    pthread_cond_signal(&cond);
    //解锁
    sleep(1);
}
//[消费者线程] 链表删除
while(1)
{
    //加锁
    if(head==NULL)
    {
        //阻塞等待
        pthread_cond_wait(&cond, &mutex);
        //条件不满足，阻塞等待并解锁
        //条件满足，解除阻塞并加锁
    }
    pNode = head;
	printf("[%d]\n", pNode->data);
	head = pNode->next
	free(pNode);
	pNode = NULL;
    //解锁
}    

```



## 4. 信号量