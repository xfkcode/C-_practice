# 网络编程(4)

## 1. 多路IO-poll

#### poll函数

```C
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
```

- 函数说明：select类似，监控多路IO，但poll不能跨平台
- 返回值：
  - 成功：`>0` 返回有事件发生结构体数量  
    					`=0` 超时没有事件发生
  - 错误：-1，并设置 `errno` 
- 参数说明：
  - `fds` ：传入传出参数（struct pollfd）:point_down: 
  - `nfds` ：内核监控文件描述范围，结构体数组最大下标+1
  - `timeout` ：超时时间
    - `=-1`：表示永久阻塞，直到有事件发生
    - `=0`：表示不阻塞，不管有没有事件发生
    - `>0`：表示阻塞时长  
                      若没有超过时长，则一直阻塞  
                      若在时长内有事件发生，则立刻返回  
                      若超过时长，则立刻返回

```C
struct pollfd {
    int   fd;         // file descriptor  (-1，内核不再监听)
    short events;     // requested events (输入参数：读事件、写事件、异常事件)
    short revents;    // returned events  (输出参数：哪些事件发生)
};
events & revents：
    POLLIN: 可读事件
    POLLOUT: 可写事件
	POLLERR: 异常事件
```

【:card_index:】poll服务端开发流程

```C
1	创建socket
2	端口复用setsockopt
3	绑定bind  
4	监听listen 
5	struct pollfd client[1024];
	client[0].fd = lfd;
	client[0].events = POLLIN;
	int maxi = 0;
	for(i=1;i<1024;i++){
        client[i].fd = -1;
    }
6	while(1){
        nready = poll(client, maxi+1, -1);
        if(nready<0){											//poll异常
            if(errno==EINTR) continue;							//被信号中断
            break;
        }
        
        //客户端连接请求到达
        if(client[0].revents & POLLIN){
            //接收新的客户端连接请求
            cfd = accept(lfd, NULL, NULL);
            
            for(i=0;i<1024;i++){
                if(client[i].fd=-1){
                    client[i].fd = cfd;
                    client[i].events = POLLIN;
                    break;
                }
            }
            
            if(i==1024){
                close(cfd);
                continue;
            }
            if(maxi<i) maxi = i;								 //修改client数组下标最大值
            if(--nready==0) continue;							//该变化处理完若再无其他则进行下一次循环
        }
        
        //客户端数据到达
        for(i=1;i<=maxi;i++){
            if(client[i].fd==-1)
                continue;
            if(client[i].revents==POLLIN){
            	//read数据
               	n = read(client[i].fd, buf, sizeof(buf));
                if(n<=0){										//read异常
                    close(client[i].fd);
                    client[i].fd = -1;
                }
                else{
                    //write数据
                	write(client[i].fd, buf, n); 
            	}
            	if(--nready==0) break;
            }
        }
    }
    close(lfd);
```

【:triangular_flag_on_post:】poll函数返回时，`fd` & `events` 不发生变化，是否有事件发生由 `revents` 判断   
			 struct pollfd 结构体成员 `fd=-1` ，表示内核没有监控  
			 poll可以突破1024

## 2. 多路IO-epoll

#### epoll_create函数

```C
#include <sys/epoll.h>
int epoll_create(int size);
```

- 函数说明：创建一棵epoll树，返回一个根节点
- 返回值：
  - 成功：大于 0 的文件描述符，代表epoll树的树根
  - 错误：-1，并设置 `errno` 
- 参数说明：
  - `size` ：最大节点数，此参数在linux2.6.8已被忽略，但必须传递一个大于 0 的数

#### epoll_ctl函数

```C
#include <sys/epoll.h>
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
```

- 函数说明：将fd添加/修改/删除至epoll树
- 返回值：
- 参数说明：
  - `epfd` ：epoll树的根节点
  - `op` ：
    - EPOLL_CTL_ADD 添加
    - EPOLL_CTL_MOD 修改
    - EPOLL_CTL_DEL 删除
  - `fd` ：文件描述符
  - `event` ：传入参数（struct epoll_event）:point_down: 

```C
typedef union epoll_data {
    void        *ptr;
    int          fd;
    uint32_t     u32;
	uint64_t     u64;
} epoll_data_t;

struct epoll_event {
	uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
events:
	EPOLLIN：可读事件
    EPOLLOUT：可写事件
    EPOLLERR：异常事件
```

#### epoll_wait函数

```C
#include <sys/epoll.h>
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```

- 函数说明：内核监控epoll树的事件节点
- 返回值：
  - 成功：`>0` 返回有事件发生结构体数量  
    			`=0` 超时没有事件发生
  - 错误：-1，并设置 `errno` 
- 参数说明：
  - `epfd` ：epoll树根节点
  - `events` ：传出参数，结构体数组（struct epoll_event）:point_up_2: 
  - `maxevents` ：数组大小
  - `timeout` ：超时时间
    - `=-1`：表示永久阻塞，直到有事件发生
    - `=0`：表示不阻塞，不管有没有事件发生
    - `>0`：表示阻塞时长  
                若没有超过时长，则一直阻塞  
                若在时长内有事件发生，则立刻返回  
                若超过时长，则立刻返回

#### epoll模型

【:cactus:】epoll服务端开发流程

```C
1	创建socket
2	端口复用setsockopt
3	绑定bind  
4	监听listen 
5	int epfd = epoll_create();									//创建epoll树
	struct epoll_event ev;
	ev.events = EPOLLIN;
	ev.data.fd = lfd;
	epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &ev);					//lfd上树
6	struct epoll_event events[1024];
    while(1){
        nready = epoll_wait(epfd, events, 1024, -1);
        if(nready<0){											//epoll异常
            if(errno==EINTR) continue;							//被信号中断
            break;
        }
        
        for(i=0;i<nready;i++){
            //客户端连接请求到达
        	if(events[i].data.fd==lfd){
            	//接收新的客户端连接请求
            	cfd = accept(lfd, NULL, NULL);
            	ev.events = EPOLLIN;
				ev.data.fd = cfd;
				epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &ev);		//cfd上树
        	}
            //客户端数据到达
            else{												 
                //read数据
               	n = read(events[i].data.fd, buf, sizeof(buf));
                if(n<=0){										//read异常
                    close(events[i].data.fd);
                    epoll_ctl(epfd, EPOLL_CTL_DEL, events[i].data.fd, NULL);
                }
                else{
                    //write数据
                	write(events[i].data.fd, buf, n); 
            	}
            }
        }
    }
    close(lfd);
```



## 3. epoll进阶



## 4. epoll反应堆



---
> ✍️ [邢福凯 (xfkcode@github)](https://github.com/xfkcode)  
> 📅 **写于2023年2月** 