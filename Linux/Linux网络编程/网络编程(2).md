# 网络编程(2)

## 1. 三次握手和四次挥手

**TCP面向连接的安全可靠的传输** 

【**客户端client**】>>> `SYN:2000(0)          mss<1024>` >>>【**服务端server**】  
                              <<< `SYN:5000(0) ACK:2001 mss<1024>` <<<  
					          >>> `ACK:5001` >>>  
  **三次握手建立连接**  
					          >>> `Seq:2001(20)` >>>  
                              <<< `Seq:5001(50) ACK:2021` <<<  
							  >>> `ACK:5051` >>>  
  **数据传输**  
                              <<< `FIN:5051(0) ACK:2021` <<<  
						      >>> `ACK:5052` >>>   
							  >>> `FIN:2021(0) ACK:5052` >>>  
							  <<< `ACK:2022` <<<  
  **四次挥手断开连接**   

【:ticket:】SYN (请求)：synchronous  
                                   本身占1位  
             ACK (确认)：acknowledgement  
                                   确认序号 = 对方发送的值 + 数据的长度   
             FIN  (结束)：finish  
                                   本身占1位

## 2. 滑动窗口

主要作用：进行流量控制  
如果发送端发送的速度较快，接收端收到数据后处理的速度较慢，而接受缓冲区的大小是固定的，就会导致接收缓冲区满而丢失数据

`win 4096` 接收缓存区可用大小，动态变化，即滑动窗口  
                   接收到数据后窗口减小，窗口减小至 0 时停止接收，读取数据后窗口扩大

`mss 1024` 一次最大接收数据量

## 3. 函数封装思想

```C
void perr_exit(const char *s)
{
    perror(s);
    exit(-1);
}

int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr)
{
    int n;
again:
    if ((n=accept(fd, sa, salenptr))<0){
        if ((error == ECONNABORTED)||(error == EINTR))
            goto again;
        else
            perr_exit("accept error");
    }
    return n;
}

int Bind(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;
    if ((n=bind(fd,sa,salen))<0)
        perr_exit("bind error");
    return n;
}

int Connect(int fd, const struct sockaddr *sa, socklen_t salen)
{
    int n;
    if ((n=connect(fd, sa, salen))<0)
        perr_exit("connect error");
    return n;
}

int Listen(int fd, int backlog)
{
    int n;
    if ((n=listen(fd, backlog))<0)
        perr_exit("listen error");
    return n;
}

int Socket(int family, int type, int protocol)
{
    int n;
    if ((n=socket(family, type, protocol))<0)
        perr_exit("socket error");
    return n;
}

ssize_t Read(int fd, void *ptr, size_t nbytes)
{
    ssize_t n;
again:
    if ((n=read(fd, ptr, nbytes))==-1){
        if (error == EINTR)
            goto again;
        else
            return -1;
    }
    return n;
}

ssize_t Write(int fd, void *ptr, size_t nbytes)
{
    ssize_t n;
again:
    if ((n=write(fd, ptr, nbytes))==-1){
        if (error == EINTR)
            goto again;
        else
            return -1;
    }
    return n;
}

int Close(int fd)
{
    int n;
    if ((n=close(fd))==-1)
        perr_exit("close error");
    return n;
}
```

【:warning:】阻塞函数在阻塞期间若收到信号，会被信号中断，`errno` 设置为` EINTR`  
             这个错误不应该看成一个错误

## 4. 粘包

粘包：多次数据发送，上一次未读完，剩余部分与下一次相连，无法区分两次发送数据分别是多少

- 解决方案1  
  包头+数据 `0010+0123456789`   
  包头4Byte表示数据长度
- 解决方案2  
  添加结尾标记  
  如在结尾加一个字符 `\n` `\$` 等（自定义协议）
- 解决方案3  
  数据包定长

## 5. 高并发服务器

#### 多进程

【:boxing_glove:】流程  
            父进程接收新的连接并回收子进程  
            子进程处理新的连接（收发数据）

```C
1	创建socket  
2	绑定bind  
3	监听listen  
4	while(1)
    {
    	//等待新的客户端连接
		cfd = accept();		//使用Accept()封装函数忽略信号打断
    	//fork
    	pid = fork();
    	if(pid<0)
        {
            exit(-1);
        }
    	else if(pid>0)		//父进程
        {
            close(cfd);
            //SIGCHLD 回收子进程
        }
    	else if(pid==0)		//子进程
        {
            close(lfd);
            while(1)
            {
                //收发数据
                n = read();	
                if(n<=0)
                    break;
                write();
            }
            close(cfd);
            exit(0);		//防止子进程再创建子进程
        }
    }
	close(lfd);
```



#### 多线程

【:atm:】



---
> ✍️ [邢福凯 (xfkcode@github)](https://github.com/xfkcode)  
> 📅 **写于2023年2月**  