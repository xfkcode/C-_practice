# 网络编程(3):shirt: 

## 1. 半关闭:satellite: 

如果一方close，另一方没有close，则认为是半关闭状态  
处于半关闭状态，可以接受数据，但是不能发送数据

【:postbox:】半关闭一定出现在主动关闭的一方

#### shutdown函数

```C
#include <sys/socket.h>
int shutdown(int sockfd, int how);
```

- 函数说明：关闭全部或部分全双工链接
- 参数说明：
  - `sockfd` ：文件描述符
  - `how` ：
    - SHUT_RD：读（接收）禁止
    - SHUT_WR： 写（发送）禁止
    - SHUT_RDWR： 读写禁止
- 返回值：
  - 成功：返回 0 
  - 失败：返回 -1，并设置 `errno` 

【:shopping_cart:】shutdown和close的区别  
             1.shutdown可实现半关闭，close不可以  
		     2.shutdown不考虑文件描述符的引用计数，直接关闭  
			    close考虑文件描述符的引用计数，只有减小到0才被真正关闭

【:atm:】长连接&短连接  
		    长连接：连接建立好之后，一直保持连接不关闭  
		    短连接：连接使用完之后立刻关闭

## 2. 心跳包:heart_decoration: 

检查与对方的网络连接是否正常  
连接异常先关闭后重建  
一般用于长连接

【:construction:】方法1  
			 不能实时检测网络情况

```C
keepAlive = 1;
setsockopt(lfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&keepAlive, sizeof(keepAlive));
```

【:blue_heart:】方法2  
 自定义协议： `4Byte数据长度 + 数据部分`   
			  A端发送 >>> `0000+AAAA`    
			  B端回复 >>> `0000+BBBB`    
 若A端多次发送B端不回复则连接异常：  
	          先关闭原连接  
	          再重建新连接

## 3. 高并发服务器:shopping_cart: 

多路IO技术：select，同时监听多个文件描述符，将监控的操作交给内核去处理

#### select函数

```C
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

- 函数描述：委托内核监控可读，可写，异常事件
- 参数说明：
  - `nfds` ：内核监控文件描述范围，一般取值最大文件描述符+1
  - `readfds` ：
    - 输入：内核监控哪些文件描述符
    - 输出：哪些文件描述符有变化
  - `writefds` ：
    - 输入：内核监控哪些文件描述符
    - 输出：哪些文件描述符有变化
  - `exceptfds` ：输入输出参数，一般表示异常事件
  - `timeout` ：超时时间
    - `NULL`：表示永久阻塞，直到有事件发生
    - `0`：表示不阻塞，不管有没有事件发生
    - `>0`：表示阻塞时长  
                若没有超过时长，则一直阻塞  
                若在时长内有事件发生，则立刻返回  
                若超过时长，则立刻返回
- 返回值：
  - 成功：返回发生变化文件描述符的数量
  - 错误：-1，并设置 `errno` 

```C
void FD_CLR(int fd, fd_set *set);		//从set集合中清除fd文件描述符
int  FD_ISSET(int fd, fd_set *set);		//判断fd是否在set集合中
void FD_SET(int fd, fd_set *set);		//将fd添加到set集合中
void FD_ZERO(fd_set *set);				//清空文件描述符集
```

【:beetle:】流程

```C
1	创建socket
2	端口复用setsockopt
3	绑定bind  
4	监听listen 
5	fd_set readfds;			//定义文件描述符集合
	fd_set tmpfds;			//定义临时(监控返回)文件描述符集合
	FD_ZERO(&readfds);		//清空文件描述符集合
	FD_ZERO(&tmpfds);		//清空临时文件描述符集合
	FD_SET(lfd, &readfds);	//将lfd加入文件描述符集合
	maxfd = lfd;
	while(1){
        tmpfds = readfds;
        nready = select(maxfd+1, &tmpfds, NULL ,NULL, NULL);
        if(nready<0){											//select异常
            if(errno==EINTR) continue;							//被信号中断
            break;
        }
        
        //客户端连接请求到达
        if(FD_ISSET(lfd, &tmpfds)){
            //接收新的客户端连接请求
            cfd = accept(lfd, NULL, NULL);
            FD_SET(cfd, &readfds);
            if(maxfd<cfd) maxfd = cfd;							//修改内核监控文件描述符的范围
            if(--nready==0) continue;							//该变化处理完若再无其他则进行下一次循环
        }
        
        //客户端数据到达
        for(i=lfd+1;i<=maxfd;i++){
            if(FD_ISSET(i, &tmpfds)){
            	//read数据
               	n = read(i, buf, sizeof(buf));
                if(n<=0){										//read异常
                    close(i);
                    FD_CLR(i, &readfds);
                }
                else{
                    //write数据
                	write(i, buf, n); 
               	}
                if(--nready==0) continue;
            }
    	}
    }
    close(lfd);
```

【:pill:**TEST**】

```C
```

