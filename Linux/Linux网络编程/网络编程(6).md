# 网络编程(6)

## libevent

### 地基event_base

使用 libevent 函数之前需要分配一个或多个 event_base 结构体，event_base 结构体相当于 epoll 红黑树的根节点   
每个 event_baes 结构体持有一个事件集合，可以检测以确定哪个事件是激活的  
每个 event_base 都有一种用于检测某种事件已经就绪的“方法”（回调函数）

```C
struct event_base *event_base_new(void);
```

- 函数说明：获得 event_base 结构体指针
- 返回值：
  - 成功：返回 event_base 结构体指针
  - 失败：返回NULL
- 参数说明：void

```C
void event_base_free(struct event_base *);
```

- 函数说明：释放 event_base 结构体指针
- 返回值：void
- 参数说明：event_base 结构体指针

```C
int event_reinit(struct event_base *base);
```

- 函数说明：  
  如果有子进程，且子进程也要使用 base，则子进程需要对 event_base 重新初始化，此时需要调用 event_reinit 函数
- 返回值：
  - 成功：返回 0
  - 失败：返回 -1
- 参数说明：
  - `base` ：由 event_base_new 返回的 event_base 结构体指针

【:printer:】查看当前系统支持的libevent方法  
		     查看当前使用的方法

```C
  1 //测试当前系统支持的libevent方法和当前使用的方法
  2 #include <stdio.h>
  3 #include <string.h>
  4 #include <stdlib.h>
  5 #include <event2/event.h>
  6 
  7 int main()
  8 {
  9     int i = 0;
 10     //当前系统支持的libevent方法
 11     const char **p = event_get_supported_methods();
 12     while(p[i]!=NULL){
 13         printf("[%s] ", p[i++]);
 14     }
 15     printf("\n");
 16 
 17     //获取地基节点
 18     struct event_base *base = event_base_new();
 19     if(base==NULL){
 20         printf("event_base_new error\n");
 21         return -1;
 22     }
 23 
 24     //当前使用的方法
 25     const char *pp = event_base_get_method(base);
 26     printf("[%s]\n", pp);
 27 
 28     //释放地基节点
 29     event_base_free(base);
 30 
 31     return 0;
 32 }

 >>>>执行结果
 [xfk@centos LIBEVENT]$ gcc -o event event.c -levent
 [xfk@centos LIBEVENT]$ ./event
 [epoll] [poll] [select] 
 [epoll]
```





---
> ✍️ [邢福凯 (xfkcode@github)](https://github.com/xfkcode)  
> 📅 **写于2023年2月** 