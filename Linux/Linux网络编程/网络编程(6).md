# 网络编程(6)

## libevent

### 地基event_base

使用 libevent 函数之前需要分配一个或多个 event_base 结构体，event_base 结构体相当于 epoll 红黑树的根节点   
每个 event_baes 结构体持有一个事件集合，可以检测以确定哪个事件是激活的  
每个 event_base 都有一种用于检测某种事件已经就绪的“方法”（回调函数）

```C
struct event_base *event_base_new(void);
```

- 函数说明：获得 event_base 结构体指针
- 返回值：
  - 成功：返回 event_base 结构体指针
  - 失败：返回NULL
- 参数说明：void

```C
void event_base_free(struct event_base *base);
```

- 函数说明：释放 event_base 结构体指针
- 返回值：void
- 参数说明：event_base 结构体指针

```C
int event_reinit(struct event_base *base);
```

- 函数说明：  
  如果有子进程，且子进程也要使用 base，则子进程需要对 event_base 重新初始化，此时需要调用 event_reinit 函数
- 返回值：
  - 成功：返回 0
  - 失败：返回 -1
- 参数说明：
  - `base` ：由 event_base_new 返回的 event_base 结构体指针

【:printer:】查看当前系统支持的libevent方法  
		     查看当前使用的方法

```C
  1 //测试当前系统支持的libevent方法和当前使用的方法
  2 #include <stdio.h>
  3 #include <string.h>
  4 #include <stdlib.h>
  5 #include <event2/event.h>
  6 
  7 int main()
  8 {
  9     int i = 0;
 10     //当前系统支持的libevent方法
 11     const char **p = event_get_supported_methods();
 12     while(p[i]!=NULL){
 13         printf("[%s] ", p[i++]);
 14     }
 15     printf("\n");
 16 
 17     //获取地基节点
 18     struct event_base *base = event_base_new();
 19     if(base==NULL){
 20         printf("event_base_new error\n");
 21         return -1;
 22     }
 23 
 24     //当前使用的方法
 25     const char *pp = event_base_get_method(base);
 26     printf("[%s]\n", pp);
 27 
 28     //释放地基节点
 29     event_base_free(base);
 30 
 31     return 0;
 32 }

 >>>>执行结果
 [xfk@centos LIBEVENT]$ gcc -o event event.c -levent
 [xfk@centos LIBEVENT]$ ./event
 [epoll] [poll] [select] 
 [epoll]
```

### 循环等待event_loop

```C
int event_base_loop(struct event_base *base, int flags);
```

- 函数说明：进入循环等待事件
- 返回值：
  - 成功：返回 `0` 
  - 错误：返回 `-1`
  - `1` ：没有事件发生或激活，退出
- 参数说明：
  - `base` ：由 event_base_new 返回的 event_base 结构体指针
  - `flags` ：
    - `#define EVLOOP_ONCE 0x01`   
      指触发一次，如果事件没有被触发，阻塞等待
    - `#define EVLOOP_NONBLOCK 0x02`   
      非阻塞方式检测事件是否被触发，不管事件触发与否，都会立即返回

```C
int event_base_dispatch(struct event_base *base);
```

- 函数说明：进入循环等待事件
- 返回值：
  - 成功：返回 `0` 
  - 错误：返回 `-1`
  - `1` ：没有事件发生或激活，退出
- 参数说明：
  - `base` ：由 event_base_new 返回的 event_base 结构体指针

```C
struct timeval{
    long tv_sec;
    long tv_usec;
};
int event_base_loopexit(struct event_base *base, const struct timeval *tv);
int event_base_loopbreak(struct event_base *);
```

【:stopwatch:】终止循环  
		     `event_base_loopexit` 如果事件触发，回调函数还未执行完，则回调函数执行结束后终止循环（如果tv非NULL，则等待设置的时间tv后立即终止循环）  
		     `event_base_loopbreak` 立即终止循环

### 事件驱动event

```C
typedef void (*event_callback_fn)(evutil_socket_t fd, short events, void *arg);
struct event *event_new(struct event_base *base, evutil_socket_t fd, short events, event_callback_fn cb, void *arg);
void event_free(struct event *ev);
```

- 函数1说明：创建 event 结构体指针，指定地基 base，文件描述符、事件、回调函数以及回调函数参数  
  函数2说明：释放 event 结构体指针
- 返回值：返回 event 结构体指针
- 参数说明：
  - `base` ：由 event_base_new 返回的 event_base 结构体指针
  - `fd` ：文件描述符
  - `events` ：监听事件
    - `#define EV_READ     0x02` 读事件
    - `#define EV_WRITE    0x04` 写事件
    - `#define EV_SIGNAL   0x08` 信号事件
    - `#define EV_PERSIST  0x10` 周期性触发
    - `#define EV_ET       0x20` 边缘触发
  - `cb` ：回调函数
  - `arg` ：回调函数参数

```C
int event_add(struct event *ev, const struct timeval *timeout);
int event_del(struct event *ev);
```

- 函数1说明：上地基  
  函数2说明：下地基

### libevent：server/client开发流程(TCP)

【**服务端server**:computer:】

```C
struct event_base *base;
struct event *Event[1024];

void readcb(evutil_socket_t fd, short events, void *arg){
    int i;
    int n;
    char buf[1024];
    memset(buf, 0x00, sizeof(buf));
    n = read(fd, buf, sizeof(buf));
    if(n<=0){
        perror("read error or client close\n");
        event_del((struct event *)arg);
        close(fd);
        return;
    }
    printf("n==[%d],buf==[%s]\n", n, buf);
    for(i=0;i<n;i++){
        buf[i] = toupper(buf[i]);
    }
    write(fd, buf, n);
}

void conncb(evutil_socket_t fd, short events, void *arg){
    int cfd = accpet(fd, NULL, NULL);
    if(cfd<0){
        perror("accept error\n");
        return;
    }
    int i;
    for(i=0;i<1024;i++){
        if(Event[i]==NULL) break;
    }
    Event[i] = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, Event[i]);
    event_add(Event[i], NULL);
}

1	创建socket
2	端口复用setsockopt
3	绑定bind  
4	监听listen
5	创建地基
    base = event_base_new();
6	创建lfd对应的event
    Event[1024] = event_new(base, lfd, EV_READ|EV_PERSIST, conncb, NULL);
7	上地基
    event_add(Event[1024], NULL);
8	事件循环
    event_base_dispatch(base);
9	释放资源
    event_free(Event[1024]);
	event_base_free(base);
10  关闭
    close(lfd);
```

【:pill:**TEST**】

```C
  1 //
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 #include <event2/event.h>
 11 
 12 struct event_base *base;
 13 struct event *Event[1024];
 14 
 15 void readcb(evutil_socket_t fd, short events, void *arg){
 16     int i;
 17     int n;
 18     char buf[1024];
 19     struct event *ev = (struct event *)arg;
 20     memset(buf, 0x00, sizeof(buf));
 21     n = read(fd, buf, sizeof(buf));
 22     if(n<=0){
 23         perror("read error or client close\n");
 24         for(i=0;i<1024;i++){
 25             if(Event[i]==ev){
 26                 Event[i] = NULL;
 27                 break;
 28             }
 29         }
 30         event_del(ev);
 31         close(fd);
 32         return;
 33     }
 34     printf("n==[%d],buf==[%s]\n", n, buf);
 35     for(i=0;i<n;i++){
 36         buf[i] = toupper(buf[i]);
 37     }
 38     write(fd, buf, n);
 39 }
 40 
 41 void conncb(evutil_socket_t fd, short events, void *arg){
 42     int cfd = accept(fd, NULL, NULL);
 43     if(cfd<0){
 44         perror("accept error\n");
 45         return;
 46     }
 47     int i;
 48     for(i=0;i<1024;i++){
 49         if(Event[i]==NULL) break;
 50     }
 51     Event[i] = event_new(base, cfd, EV_READ|EV_PERSIST, readcb, Event[i]);
 52     event_add(Event[i], NULL);
 53 }
 54 
 55 int main()
 56 {
 57     //
 58     int lfd = socket(AF_INET, SOCK_STREAM, 0);
 59     if(lfd<0){
 60         perror("socket error\n");
 61         return -1;
 62     }
 63     //
 64     int opt = 1;
 65     setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(int));
 66     //
 67     struct sockaddr_in serv;
 68     bzero(&serv, sizeof(serv));
 69     serv.sin_family = AF_INET;
 70     serv.sin_port = htons(8888);
 71     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 72     int ret = bind(lfd, (struct sockaddr*)&serv, sizeof(serv));
 73     if(ret<0){
 74         perror("bind error\n");
 75         return -1;
 76     }
 77     //
 78     listen(lfd, 128);
 79     //  
 80     base = NULL;
 81     base = event_base_new();
 82     //
 83     int i;
 84     for(i=0;i<1024;i++) Event[i] = NULL;
 85     Event[1024] = event_new(base, lfd, EV_READ|EV_PERSIST, conncb, NULL);
 86     //
 87     event_add(Event[1024], NULL);
 88     //
 89     event_base_dispatch(base);
 90     //
 91     event_free(Event[1024]);
 92     event_base_free(base);
 93     //
 94     close(lfd);
 95     return 0;
 96 }

```



【**客户端client**:iphone:】

```C
```

【:pill:**TEST**】

```C
```



---
> ✍️ [邢福凯 (xfkcode@github)](https://github.com/xfkcode)  
> 📅 **写于2023年2月** 