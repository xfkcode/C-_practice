# 网络编程(5)

## 1. 线程池



## 2. UDP通信

UDP：用户数据报协议  
面向无连接的，不稳定的，不可靠的，不安全的数据报传递（类似收发短信）  
UDP传输不需要建立连接，传输效率更高，在稳定的局域网内环境相对可靠 

### recvfrom函数

```C
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen);
```

- 函数说明：接收消息
- 返回值：
  - 成功：返回读到的字节数
  - 失败：返回 -1 ，并设置 `errno` 
- 参数说明：
  - `sockfd` ：套接字
  - `buf` ：要接收的缓冲区
  - `len` ：缓冲区的长度
  - `flags` ：标志位，一般填 0
  - `src_addr` ：原地址传出参数
  - `addrlen` ：发送方地址长度

### sendto函数

```C
#include <sys/types.h>
#include <sys/socket.h>
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen);
```

- 函数说明：发送数据
- 返回值：
  - 成功：返回写入的字节数
  - 失败：返回 -1 ，并设置 `errno` 
- 参数说明：
  - `sockfd` ：套接字
  - `buf` ：要发送的缓冲区
  - `len` ：缓冲区的长度
  - `flags` ：标志位，一般填 0
  - `dest_addr` ：目的地址
  - `addrlen` ：目的的地址长度

### UDP：server/client开发流程

【**服务端server**:computer:】

```C
1	创建socket,type = SOCK_DGRAM
2	绑定bind
3   while(1){
    	收消息recvfrom
        发消息sendto
	}
4	关闭close
```

【:pill:**TEST**】

```C
  1 //UDP服务器测试
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 
 11 int main()
 12 {
 13     //创建socket
 14     int cfd = socket(AF_INET, SOCK_DGRAM, 0);
 15     if(cfd<0){
 16         perror("socket error");
 17         return -1;
 18     }
 19     //绑定
 20     struct sockaddr_in serv;
 21     struct sockaddr_in client;
 22     bzero(&serv, sizeof(serv));
 23     serv.sin_family = AF_INET;
 24     serv.sin_port = htons(8888);
 25     serv.sin_addr.s_addr = htonl(INADDR_ANY);
 26     int ret = bind(cfd, (struct sockaddr*)&serv, sizeof(serv));
 27     if(ret<0){
 28         perror("bind error");
 29         return -1;
 30     }
 31 
 32     int i = 0;
 33     int n = 0;
 34     socklen_t len;
 35     char buf[1024];
 36     while(1){
 37         //接收数据
 38         memset(buf, 0x00, sizeof(buf));
 39         len = sizeof(client);
 40         n = recvfrom(cfd, buf, sizeof(buf), 0, (struct sockaddr *)&client, &len);
 41         printf("[%d]:n==[%d],buf==[%s]\n", ntohs(client.sin_port), n, buf);
 42         //发送数据
 43         for(i=0;i<n;i++){
 44             buf[i] = toupper(buf[i]);
 45         }
 46         sendto(cfd, buf, n, 0, (struct sockaddr *)&client, len);
 47     }
 48     //关闭  
 49     close(cfd);
 50     return 0;
 51 }

 >>>>执行结果
 [xfk@centos SOCKET]$ ./server_UDP
 [51115]:n==[4],buf==[xfk
 ]
 [37561]:n==[3],buf==[tq
 ]
 [xfk@centos ~]$ nc -u 127.1 8888
 xfk
 XFK
 [xfk@centos ~]$ nc -u 127.1 8888
 tq
 TQ
```

【:ticket:】`nc -u 127.1 8888` ：`-u` 参数，可测试UDP

【:construction:】查看网络状态

```Linux
[xfk@centos ~]$ netstat -anp | grep 8888
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
udp        0      0 0.0.0.0:8888            0.0.0.0:*                           30392/./server_UDP  
udp        0      0 127.0.0.1:37561         127.0.0.1:8888          ESTABLISHED 30393/nc            
udp        0      0 127.0.0.1:51115         127.0.0.1:8888          ESTABLISHED 30448/nc
```

【**客户端client**:iphone:】

```C
1	创建socket
2   while(1){
        发消息sendto
        收消息recvfrom
	}
3	关闭close
```

【:pill:**TEST**】

```C
  1 //UDP客户端测试
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <unistd.h>
  7 #include <sys/socket.h>
  8 #include <arpa/inet.h>
  9 #include <ctype.h>
 10 
 11 int main()
 12 {
 13     //创建socket
 14     int cfd = socket(AF_INET, SOCK_DGRAM, 0);
 15     if(cfd<0){
 16         perror("socket error");
 17         return -1;
 18     }
 19 
 20     int i = 0;
 21     int n = 0;
 22     char buf[1024];
 23     struct sockaddr_in serv;
 24 
 25     serv.sin_family = AF_INET;
 26     serv.sin_port = htons(8888);
 27     inet_pton(AF_INET, "127.0.0.1", &serv.sin_addr.s_addr);
 28 
 29     while(1){
 30         //发送数据
 31         memset(buf, 0x00, sizeof(buf));
 32         n = read(STDIN_FILENO, buf, sizeof(buf));
 33         sendto(cfd, buf, n, 0, (struct sockaddr *)&serv, sizeof(serv));
 34         //接收数据
 35         memset(buf, 0x00, sizeof(buf));
 36         n = recvfrom(cfd, buf, sizeof(buf), 0, NULL, NULL);
 37         printf("[server]:n==[%d],buf==[%s]\n", n, buf);
 38     }
 39     //关闭  
 40     close(cfd);
 41     return 0;
 42 }

 >>>>执行结果
 [xfk@centos SOCKET]$ ./server_UDP
 [50712]:n==[4],buf==[xfk
 ]
 [38975]:n==[3],buf==[tq
 ]
 [xfk@centos SOCKET]$ ./client_UDP 
 xfk
 [server]:n==[4],buf==[XFK
 ]
 [xfk@centos SOCKET]$ ./client_UDP 
 tq
 [server]:n==[3],buf==[TQ
 ]
```

【:construction:】查看网络状态

```Linux
[xfk@centos ~]$ netstat -anp | grep server
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
Active Internet connections (servers and established)
udp        0      0 0.0.0.0:8888            0.0.0.0:*                           31315/./server_UDP  
Active UNIX domain sockets (servers and established)
[xfk@centos ~]$ netstat -anp | grep client
(Not all processes could be identified, non-owned process info
 will not be shown, you would have to be root to see it all.)
udp        0      0 0.0.0.0:50712           0.0.0.0:*                           31343/./client_UDP  
udp        0      0 0.0.0.0:38975           0.0.0.0:*                           31330/./client_UDP
```

## 3. 本地socket通信