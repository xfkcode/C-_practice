# 信号:signal_strength: 

**信号介绍** :vertical_traffic_light: 

- 信号的概念

  信号是信息的载体，Linux/Unix环境下，古老、金典的通信方式，现下依然是主要的通信手段

  - 信号的特点
    - 简单
    - 不能携带大量信息
    - 满足某个特点条件才会产生

## 1. 信号的机制

进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕后再继续执行。与硬件中断类似（异步模式）。但信号是软件层面上实现的中断，早期常被称为“软中断”。

【:ticket:】每个进程收到的所有信号，都是由内核负责发送的

### 1.1 信号的状态

**信号有三个状态：产生、未决和递达** 

- 信号的产生：
  - 按键产生，`Ctrl+c` `Ctrl+z` `Ctrl+\` 
  - 系统调用产生，`kill` `raise` `abort` 
  - 软条件产生，`定时器alarm`
  - 硬件异常产生，非法访问内存（段错误）、除0（浮点数例外）、内存对齐出错（总线错误）
  - 命令产生，`kill命令` 
- 未决：产生和递达之间的状态，主要由于阻塞（屏蔽）导致该状态
- 递达：递送并且到达进程

```Linux
[xfk@centos PIPE]$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX 
```

### 1.2 信号的处理方式

:bookmark_tabs:手册查看 `man 7 signal` 

Term   Default action is to terminate the process.  
Ign       Default action is to ignore the signal.   
Core    Default action is to terminate the process and dump core.  
Stop    Default action is to stop the process.  
Cont    Default action is to continue the process if it is currently stopped.

- 执行默认动作
- 忽略信号（丢弃不处理）
- 捕捉信号（调用用户的自定义的处理函数）

 【:loudspeaker:】**The signals** `SIGKILL` **and** `SIGSTOP` **cannot be caught, blocked, or ignored.** 

### 1.3 信号的特性

信号的实现手段导致信号**有很强的延时性**，但对于用户来说，时间非常短，不易察觉

Linux内核的进程控制块PCB是一个结构体，`task_struct` ，除包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号的相关信息，主要指阻塞信号集和未决信号集

### 1.4 阻塞信号集和未决信号集



### 1.5 信号的四要素 

- 信号的编号
- 信号的名称
- 产生信号的事件
- 信号的默认处理动作（大部分终止）  
  `Term` 终止进程 / `Ign` 忽略信号 / `Core` 终止进程，生成Core文件 / `Stop` 停止（暂停）进程 / `Cont` 继续运行进程

## 2. 信号的相关函数

### 2.1 signal函数

```C
 #include <signal.h>
```

- 函数作用：注册信号捕捉函数
- 函数原型：  
  `typedef void (*sighandler_t)(int);`   
  `sighandler_t signal(int signum, sighandler_t handler);` 
- 函数参数：
  - `signum` 信号编号
  - `handler` 信号处理函数

```C
  1 //signal函数测试：没有读端管道写数据，会产生SIGPIPE信号
  2 #include<stdio.h>
  3 #include<stdlib.h>
  4 #include<string.h>
  5 #include<sys/types.h>
  6 #include<unistd.h>
  7 #include<sys/wait.h>
  8 #include<signal.h>
  9 
 10 //信号处理函数
 11 void sighandler(int signo)
 12 {
 13     printf("signo==[%d]\n", signo);
 14 }
 15 int main()
 16 {
 17     //创建管道
 18     int fd[2];
 19     int ret = pipe(fd);
 20     if (ret<0)
 21     {
 22         perror("pipe error");
 23         return -1;
 24     }
 25     //注册SIGPIPE信号处理函数
 26     signal(SIGPIPE, sighandler);
 27     //关闭读端
 28     close(fd[0]);
 29 
 30     write(fd[1], "hello world", strlen("hello world"));
 31 
 32     return 0;
 33 }

 >>>>执行结果
 [xfk@centos PIPE]$ ./pipe_sig 
 signo==[13]
```



### 2.2 kill函数/命令

### 2.3 abort函数/raise函数

### 2.4 alarm函数

### 2.5 setitimer函数

## 3. 信号集相关

## 4. 信号捕捉函数

## 5. SIGCHLD信号