# 守护进程和线程

## 1. 守护进程

### 1.1 守护进程介绍

**Daemon**（精灵）进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。  
一般采取以d结尾的名字，如：`vsftpd` 

Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。  
如：预读入缓输出机制的实现；`ftp` 服务器；`nfs` 服务器等。

【:ticket:】**守护进程特点**   
            :one: Linux后台服务进程  :two: 独立于控制终端  :three: 周期性的执行某种任务  :four: 不受用户登录和注销的影响  :five: 一般采用d结尾的名字

### 1.2 进程组和会话

- **进程组** 
  - **进程组是一个或者多个进程的集合**，每个进程都属于一个进程组，引入进程组是为了进化对进程的管理。当父进程创建子进程的时候，默认子进程与父进程属于同一个进程组

【:boxing_glove:】**进程组ID == 第一个进程ID（组长进程）**  
             如父进程创建了多个子进程，父进程和多个子进程同属于一个组，而且父进程是进程组里的第一个进程，所以父进程就是这个组的组长  
             组长ID == 父进程ID

【:warning:】`kill -SIGKILL -进程组ID(负)` 杀死进程组所有进程

【:four_leaf_clover:】进程组生存期：从进程创建到最后一个进程离开  
            只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关

- **会话** 
  - **一个会话是一个或多个进程组的集合** 

【:key:】创建会话的进程不能是进程组组长  
             创建会话的进程成为一个进程的组长进程，同时也成为会话的会长  
             需要root权限（有的系统不需要）  
             新创建的会话丢弃原有的控制终端

【:tractor:】创建新会话  
             先调用 `fork` ，父进程终止，子进程调用 `setsid` 函数

`ps ajx` 查看进程组ID和会话ID  
`PPID` 父进程ID  `PID` 进程ID  `PGID` 进程组ID `SID` 会话ID

```Linux
[xfk@centos COMP_SIGNAL]$ ps ajx
  PPID    PID   PGID    SID TTY       TPGID STAT   UID   TIME COMMAND
     0      1      1      1 ?            -1 Ss       0   0:03 /usr/lib/systemd/sys
     0      2      0      0 ?            -1 S        0   0:00 [kthreadd]
     2      3      0      0 ?            -1 S        0   0:00 [ksoftirqd/0]
  ...
```

### 1.3 创建守护进程的模型

<font color=deeppink>**第一步：fork 子进程，父进程退出**</font>   
               保证子进程ID不是进程组ID

<font color=deeppink>**第二步：子进程调用 setsid 函数创建新会话**</font>  
                该进程成为新会话的首进程，是会话的会长  
                该进程成为一个新进程组的组长进程，是进程组组长  
                不受控制终端的影响

第三步：改变当前工作目录 chdir （非必要）

第四步：重设文件掩码（非必要） `mode & ~umask`   
                子进程继承父进程的掩码，受到约束。  
				>>>直接设置 `umask(0000);` 

第五步：关闭文件描述符（非必要）  
                `close(STDIN_FILENO);` `close(STDOUT_FILENO);` `close(STDERR_FILENO);` 

<font color=deeppink>**第六步：执行核心操作**</font>  
                守护进程的核心代码逻辑

```C
  1 //创建守护进程
  2 #include <stdio.h>
  3 #include <stdlib.h>
  4 #include <string.h>
  5 #include <sys/types.h>
  6 #include <sys/stat.h>
  7 #include <fcntl.h>
  8 #include <unistd.h>
  9 #include <signal.h>
 10 #include <sys/time.h>
 11 #include <time.h>
 12 
 13 void func(int signo)
 14 {
 15     //打开文件
 16     int fd = open("daemon.log", O_RDWR | O_CREAT | O_APPEND, 0755);
 17     if(fd<0)
 18     {
 19         return;
 20     }
 21 
 22     //获取当前系统时间
 23     time_t t;
 24     time(&t);
 25     char *p = ctime(&t);
 26 
 27     //将时间写入文件
 28     write(fd, p, strlen(p));
 29 
 30     //关闭文件
 31     close(fd);
 32 }
 33 
 34 int main()
 35 {
 36     //创建子进程
 37     pid_t pid = fork();
 38     if(pid<0||pid>0)
 39     {
 40         exit(1);
 41     }
 42 
 43     //创建会话
 44     setsid();
 45 
 46     //修改当前工作目录（非必要）
 47     //chdir("");
 48 
 49     //重设文件掩码
 50     umask(0000);
 51 
 52     //关闭文件描述符
 53     close(STDIN_FILENO);
 54     close(STDOUT_FILENO);
 55     close(STDERR_FILENO);
 56 	//核心操作
 57     //创建信号处理函数
 58     struct sigaction act;
 59     act.sa_handler = func;
 60     act.sa_flags = 0;
 61     sigemptyset(&act.sa_mask);
 62     sigaction(SIGALRM, &act, NULL);
 63 
 64     //设置定时器
 65     struct itimerval tm;
 66     tm.it_interval.tv_sec = 2;
 67     tm.it_interval.tv_usec = 0;
 68     tm.it_value.tv_sec = 3;
 69     tm.it_value.tv_usec = 0;
 70     setitimer(ITIMER_REAL, &tm, NULL);
 71 
 72     while(1)
 73     {
 74         sleep(1);
 75     }
 76     return 0;
 77 }

 >>>>执行结果
 [xfk@centos DAEMON]$ ps ajx | grep ./daemon
     1  13671  13671  13671 ?            -1 Ss    1000   0:00 ./daemon
 [xfk@centos DAEMON]$ tail -f daemon.log
 Tue Jan 24 20:56:36 2023
 Tue Jan 24 20:56:38 2023
 Tue Jan 24 20:56:40 2023
 Tue Jan 24 20:56:42 2023
 ^C
```

## 2. 线程

### 2.1 什么是线程

轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程

- 进程：拥有独立的地址空间，拥有PCB，相当于独居

- 线程：有PCB，但没有独立的地址空间，多个线程共享进程空间，相当于合租

【:bowling:】**系统分配资源的最基本单位是：进程**  
             **系统调度进程执行的最小单位是：线程**  
             多个子线程和主线程共享一个地址空间，有一个PID，通过使用线程号来区分不同的线程，  
             主线程和子线程执行先后不一定，看谁先抢到cpu资源    

除了栈空间以外，其余资源都可以共享

## 3. 线程属性

## 4. 线程同步





---
> ✍️ [邢福凯 (xfkcode@github)](https://github.com/xfkcode)  
> 📅 **写于2023年1月**  